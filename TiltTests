#include "M5Atom.h"

int white (0xffffff), red (0x00ff00), orange (0xa5ff00), yellow (0xffff00), green (0xff0000), blue (0x0000ff), purple (0x008080), black (0x000000);  //Helps reference colors codes by name
int palette[] = {black, white, orange};  //Select color palette by putting in order (credit: Mike Klepper)

//Function that takes a 25 element matrix of image data and prints it on the display (credit: Mike Klepper)
void drawArray(int shapeMatrix[], int colors[]) {
  for (int i = 0; i < 25; i++) {
    if (colors[shapeMatrix[i]] != black)
      M5.dis.drawpix(i, colors[shapeMatrix[i]]);
  }
}

//Following is a series of arrays of pixel data which can be used to code an image on the display (credit: Mike Klepper)
int upArrow[25] = { 0, 0, 1, 0, 0,
                    0, 1, 1, 1, 0,
                    1, 0, 1, 0, 1,
                    0, 0, 1, 0, 0,
                    0, 0, 1, 0, 0
                  };

int downArrow[25] = { 0, 0, 1, 0, 0,
                      0, 0, 1, 0, 0,
                      1, 0, 1, 0, 1,
                      0, 1, 1, 1, 0,
                      0, 0, 1, 0, 0
                    };

int leftArrow[25] = { 0, 0, 1, 0, 0,
                      0, 1, 0, 0, 0,
                      1, 1, 1, 1, 1,
                      0, 1, 0, 0, 0,
                      0, 0, 1, 0, 0
                    };

int rightArrow[25] = { 0, 0, 1, 0, 0,
                       0, 0, 0, 1, 0,
                       1, 1, 1, 1, 1,
                       0, 0, 0, 1, 0,
                       0, 0, 1, 0, 0
                     };

int circle[25] = { 0, 1, 1, 1, 0,
                       1, 0, 0, 0, 1,
                       1, 0, 0, 0, 1,
                       1, 0, 0, 0, 1,
                       0, 1, 1, 1, 0
                     };

int circleWithX[25] = { 0, 1, 1, 1, 0,
                        1, 0, 2, 0, 1,
                        1, 2, 2, 2, 1,
                        1, 0, 2, 0, 1,
                        0, 1, 1, 1, 0
                      };


float tiltThreshold = .5;  //We tested to find this value which defines the angles at which the device must be tilted at to be considered as facing certain directions
float aX, aY, aZ;

void setup() {
  M5.begin(true, false, true);
  M5.IMU.Init();  //Starts up the hardware in the device which detects acceleration, gyration, and temperature
}

void loop() {
  M5.IMU.getAccelData(&aX, &aY, &aZ);  //Gets acceleration data from the device

  //We use Mike Klepper's tilt threshold idea to help differentiate when the device is oriented in different directions (https://patriot-geek.blogspot.com/2020/05/atom-matrix-using-mpu6886-accelerometer.html)
  if (abs(aX) < tiltThreshold && abs(aY) < tiltThreshold && aZ > tiltThreshold)
    drawArray(circle, palette);
  else if (abs(aX) < tiltThreshold && abs(aY) < tiltThreshold && aZ < -tiltThreshold)
    drawArray(circleWithX, palette);
  else if (abs(aX) < tiltThreshold && aY > tiltThreshold && abs(aZ) < tiltThreshold)
    drawArray(upArrow, palette);
  else if (abs(aX) < tiltThreshold && aY < -tiltThreshold && abs(aZ) < tiltThreshold)
    drawArray(downArrow, palette);
  else if (aX > tiltThreshold && abs(aY) < tiltThreshold && abs(aZ) < tiltThreshold)
    drawArray(leftArrow, palette);
  else if (aX < -tiltThreshold && abs(aY) < tiltThreshold && abs(aZ) < tiltThreshold)
    drawArray(rightArrow, palette);
  else
    M5.dis.clear();  //If not clearly tilted to face the given directions the screen will be blank

  M5.update();
}
